# SPDX-FileCopyrightText: 2025 MDAD project contributors
# SPDX-License-Identifier: AGPL-3.0-or-later

---
# Display version summary with current states and changes

# Resolve runtime configuration from role variables
- name: Resolve summary configuration
  ansible.builtin.set_fact:
    summary_scope_value: "{{ docker_summary_scope | default('matrix-*') }}"
    summary_versions_fact_file: "{{ docker_summary_versions_fact_file | default('matrix_versions.fact') }}"
    summary_versions_fact_key: "{{ (docker_summary_versions_fact_file | default('matrix_versions.fact')) | regex_replace('\\.fact$', '') }}"
    summary_history_fact_file: "{{ docker_summary_history_fact_file | default('matrix_version_history.fact') }}"
    summary_history_fact_key: "{{ (docker_summary_history_fact_file | default('matrix_version_history.fact')) | regex_replace('\\.fact$', '') }}"
    summary_display_enabled: "{{ docker_summary_display | default(true) | bool }}"
    summary_history_max_entries: "{{ docker_summary_history_max_entries | default(100) | int }}"
    summary_retention_days: "{{ docker_summary_retention_days | default(365) | int }}"
    summary_table_style_unicode: "{{ docker_summary_table_style_unicode | default(false) | bool }}"
    summary_table_service_width: "{{ docker_summary_table_service_width | default(30) | int }}"
    summary_table_version_width: "{{ docker_summary_table_version_width | default(25) | int }}"
    summary_table_status_width: "{{ docker_summary_table_status_width | default(18) | int }}"
    summary_table_auto_width: "{{ docker_summary_table_auto_width | default(false) | bool }}"
    summary_table_service_width_min: "{{ docker_summary_table_service_width_min | default(docker_summary_table_service_width | default(30)) | int }}"
    summary_table_service_width_max: "{{ docker_summary_table_service_width_max | default(60) | int }}"
    summary_table_version_width_min: "{{ docker_summary_table_version_width_min | default(docker_summary_table_version_width | default(25)) | int }}"
    summary_table_version_width_max: "{{ docker_summary_table_version_width_max | default(50) | int }}"
    summary_table_status_width_min: "{{ docker_summary_table_status_width_min | default(docker_summary_table_status_width | default(18)) | int }}"
    summary_table_status_width_max: "{{ docker_summary_table_status_width_max | default(30) | int }}"
    summary_table_show_notes: "{{ docker_summary_table_show_notes | default(false) | bool }}"
    summary_table_notes_width: "{{ docker_summary_table_notes_width | default(24) | int }}"
    summary_table_notes_width_min: "{{ docker_summary_table_notes_width_min | default(docker_summary_table_notes_width | default(24)) | int }}"
    summary_table_notes_width_max: "{{ docker_summary_table_notes_width_max | default(48) | int }}"
    summary_table_notes_include_state: "{{ docker_summary_table_notes_include_state | default(true) | bool }}"
    summary_version_extract_smart: "{{ docker_summary_version_extract_smart | default(true) | bool }}"

# Detect execution context to determine appropriate behavior
- name: Detect execution context
  ansible.builtin.set_fact:
    status_check_mode: >-
      {{
        (
          ansible_run_tags is defined and
          (ansible_run_tags | length == 1) and
          ((ansible_run_tags | first) == 'docker-ansible-summary')
        )
        or
        (docker_summary_mode | default('changes')) == 'status'
      }}
    status_mode_requested: "{{ (docker_summary_mode | default('changes')) == 'status' }}"

- name: Debug execution context
  ansible.builtin.debug:
    msg: |
      ansible_run_tags: {{ ansible_run_tags | default('undefined') }}
      status_check_mode: {{ status_check_mode }}
      status_mode_requested: {{ status_mode_requested | default(false) }}
      current_versions length: {{ current_versions | default({}) | length }}
      after_versions length: {{ after_versions | default({}) | length }}
    verbosity: 1

- name: Skip version summary display if feature disabled
  ansible.builtin.meta: end_play
  when: not (summary_display_enabled | bool)

# Initialise container catalogue and discovery flags
- name: Initialize container catalogue
  ansible.builtin.set_fact:
    all_containers: []
    filtered_containers: []
    container_inspect_map: {}
    current_metadata_map: {}
    summary_discovery_available: "{{ docker_summary_container_overrides | length > 0 }}"

- name: Seed container catalogue from provided overrides
  ansible.builtin.set_fact:
    all_containers: "{{ docker_summary_container_overrides | map('combine', {}) | list }}"
  when: docker_summary_container_overrides | length > 0

- name: Seed inspect data from overrides
  ansible.builtin.set_fact:
    container_inspect_map: "{{ container_inspect_map | combine({item.name: item.inspect}) }}"
  loop: "{{ docker_summary_container_overrides }}"
  when:
    - docker_summary_container_overrides | length > 0
    - item.inspect is defined

- name: Discover Docker containers via community.docker
  when:
    - docker_summary_enable_discovery | default(true) | bool
    - docker_summary_container_overrides | length == 0
  block:
    - name: Query running Docker containers
      community.docker.docker_host_info:
        containers: true
        verbose_output: true
      register: docker_discovery
      changed_when: false

    - name: Build catalogue from module discovery
      ansible.builtin.set_fact:
        all_containers: "{{ all_containers + [{'name': item | docker_summary_container_name, 'image': item | docker_summary_container_image}] }}"
        summary_discovery_available: true
      loop: "{{ docker_discovery.containers | default([]) }}"
      when: (item | docker_summary_container_name) | length > 0
  rescue:
    - name: Abort when Docker host inspection fails
      ansible.builtin.fail:
        msg: >-
          Docker Ansible Summary requires the Docker SDK for Python and access to the Docker daemon on the managed host.
          Install python3-docker (or `pip install docker`) and ensure the Docker service is reachable before rerunning.

- name: Normalize scope configuration
  ansible.builtin.set_fact:
    summary_scope_patterns_clean: "{{ summary_scope_value | docker_scope_patterns }}"
    summary_scope_all: "{{ summary_scope_value | docker_scope_all }}"

- name: Apply container scope
  ansible.builtin.set_fact:
    filtered_containers: "{{ all_containers | docker_scope_filter(summary_scope_value) }}"
  when: summary_discovery_available | default(false) | bool

- name: Determine containers missing inspect metadata
  ansible.builtin.set_fact:
    summary_missing_inspect_names: "{{ filtered_containers | map(attribute='name') | list | difference(container_inspect_map.keys() | list) }}"
  when:
    - summary_discovery_available | default(false) | bool
    - filtered_containers | length > 0

- name: Gather container inspect data for missing services
  community.docker.docker_container_info:
    name: "{{ summary_missing_inspect_names }}"
  register: docker_container_info
  changed_when: false
  failed_when: false
  when:
    - summary_missing_inspect_names is defined
    - summary_missing_inspect_names | length > 0
    - docker_summary_enable_discovery | default(true) | bool

- name: Merge gathered inspect metadata
  ansible.builtin.set_fact:
    container_inspect_map: "{{ container_inspect_map | combine({(item.Name | default('') | regex_replace('^/', '')): item}) }}"
  loop: "{{ docker_container_info.containers | default([]) }}"
  when:
    - docker_summary_enable_discovery | default(true) | bool
    - docker_container_info is defined
    - not (docker_container_info.failed | default(false))

# Initialize data structures
- name: Process current versions
  ansible.builtin.set_fact:
    current_versions: "{{ current_versions | default({}) }}"
    after_versions: "{{ after_versions | default({}) }}"

- name: Resolve cached local facts
  ansible.builtin.set_fact:
    summary_local_facts: "{{ (docker_summary_ansible_local_override if docker_summary_ansible_local_override is not none else ansible_local) | default({}) }}"

- name: Load previous snapshots
  ansible.builtin.set_fact:
    version_history: "{{ history_snapshot }}"
    before_versions: "{{ summary_local_facts | docker_summary_fact(summary_versions_fact_key) }}"
    before_metadata: "{{ history_snapshot.last_metadata | default({}) }}"
  vars:
    history_snapshot: "{{ summary_local_facts | docker_summary_fact(summary_history_fact_key) | docker_summary_ensure_history }}"

- name: Filter previous snapshots to current scope
  ansible.builtin.set_fact:
    before_versions: "{{ before_versions | docker_scope_filter_dict(summary_scope_value) }}"
    before_metadata: "{{ before_metadata | docker_scope_filter_dict(summary_scope_value) }}"

- name: Derive baseline service list
  ansible.builtin.set_fact:
    summary_known_services: "{{ before_versions | dict2items | map(attribute='key') | list }}"
    summary_first_run: "{{ before_versions | length == 0 }}"

# Process container versions with improved validation
- name: Process version changes for each service
  ansible.builtin.set_fact:
    current_versions: "{{ current_versions | combine({item_name: item_version}) }}"
    current_metadata_map: "{{ current_metadata_map | combine({item_name: metadata_details}) }}"
  vars:
    item_name: "{{ item.name }}"
    full_image: "{{ item.image }}"
    inspect_data: "{{ container_inspect_map[item_name] | default({}) }}"
    metadata_details: "{{ full_image | docker_summary_metadata(inspect_data) }}"
    item_version: "{{ full_image | docker_summary_version(summary_version_extract_smart) }}"
  loop: "{{ filtered_containers }}"
  when:
    - filtered_containers | length > 0

# Build version changes dict with change tracking metadata
- name: Build version changes dict
  ansible.builtin.set_fact:
    after_versions: "{{ after_versions | combine({item: new_entry}) }}"
  vars:
    change_meta: "{{ item | docker_summary_change_meta(current_versions, before_versions, summary_first_run) }}"
    metadata_bundle:
      current: "{{ current_metadata_map[item] | default({}) }}"
      previous: "{{ before_metadata.get(item, {}) }}"
    new_entry:
      current: "{{ current_versions[item] }}"
      previous: "{{ before_versions.get(item) }}"
      status: "{{ change_meta.status }}"
      change_type: "{{ change_meta.change_type }}"
      metadata: "{{ metadata_bundle }}"
  loop: "{{ current_versions.keys() | list }}"
  when:
    - current_versions | length > 0
    - not (status_check_mode | default(false) | bool)

# In status check mode, create a status display dict without change detection
- name: Build status display dict for tag-only execution
  ansible.builtin.set_fact:
    after_versions: "{{ after_versions | combine({item: status_entry}) }}"
  vars:
    status_entry:
      current: "{{ current_versions[item] }}"
      previous: "{{ current_versions[item] }}"
      status: 'CURRENT'
      change_type: 'status'
      metadata:
        current: "{{ current_metadata_map[item] | default({}) }}"
        previous: "{{ current_metadata_map[item] | default({}) }}"
  loop: "{{ current_versions.keys() | list }}"
  when:
    - current_versions | length > 0
    - status_check_mode | default(false) | bool

- name: Debug after_versions after status mode building
  ansible.builtin.debug:
    msg: "after_versions after status mode: {{ after_versions | length }} items"
    verbosity: 1
  when:
    - current_versions | length > 0
    - status_check_mode | default(false) | bool

- name: Add removed services to summary (normal mode)
  ansible.builtin.set_fact:
    after_versions: "{{ after_versions | combine({item: removed_entry}) }}"
  vars:
    removed_entry:
      current: '(removed)'
      previous: "{{ before_versions.get(item) }}"
      status: 'CHANGED'
      change_type: 'removed'
      metadata:
        current: {}
        previous: "{{ before_metadata.get(item, {}) }}"
  loop: "{{ before_versions.keys() | list }}"
  when:
    - not (status_check_mode | default(false) | bool)
    - before_versions | length > 0
    - item not in current_versions

- name: Build status labels for output
  ansible.builtin.set_fact:
    after_versions: >-
      {{ after_versions | combine({
        item.key: item.value | combine({'status_label': status_label})
      }) }}
  vars:
    status_label: "{{ item.value | docker_summary_status_label }}"
  loop: "{{ after_versions | dict2items }}"

- name: Build notes for output
  ansible.builtin.set_fact:
    after_versions: >-
      {{ after_versions | combine({
        item.key: item.value | combine({'notes': note_value})
      }) }}
  vars:
    note_value: "{{ item.value | docker_summary_notes(summary_table_notes_include_state) }}"
  loop: "{{ after_versions | dict2items }}"
  when: summary_table_show_notes | bool

# Set display and change tracking variables
- name: Set display and change tracking variables
  ansible.builtin.set_fact:
    has_changes: >-
      {{ after_versions.values() |
         selectattr('change_type', 'in', ['added', 'updated', 'removed']) |
         list | length > 0 }}
    first_run: "{{ summary_first_run | default(false) }}"
    is_status_display: "{{ status_check_mode | default(false) | bool }}"

- name: Determine whether to show summary table
  ansible.builtin.set_fact:
    summary_show_table: >-
      {{
        (docker_summary_table_always_show | default(false) | bool)
        or (is_status_display | bool)
        or (has_changes | bool)
        or (first_run | bool)
      }}

# Only handle history recording when not in status check mode
- name: Record changes to history when changes exist
  ansible.builtin.set_fact:
    version_history_changes: {}
  when: has_changes and not is_status_display

- name: Update history with new changes
  ansible.builtin.set_fact:
    version_history_changes: >-
      {{ version_history_changes | default({}) | combine({
        item.key: {
          'previous': item.value.previous,
          'current': item.value.current,
          'metadata': item.value.metadata
        }
      }) }}
  loop: "{{ after_versions | dict2items }}"
  when: has_changes and item.value.change_type not in ['unchanged', 'status'] and not is_status_display

- name: Get current timestamp
  ansible.builtin.set_fact:
    current_timestamp: >-
      {{ ansible_date_time.year }}-{{ ansible_date_time.month }}-{{ ansible_date_time.day }}
      {{ ansible_date_time.hour }}:{{ ansible_date_time.minute }}:{{ ansible_date_time.second }}
  when: (has_changes or first_run) and not is_status_display

- name: Get current username
  ansible.builtin.set_fact:
    current_user: "{{ ansible_user_id | default(lookup('env', 'USER') | default(lookup('env', 'USERNAME') | default('unknown'))) }}"
  when: (has_changes or first_run) and not is_status_display

# Record initial state on first run
- name: Record initial state for full history
  ansible.builtin.set_fact:
    first_run_changes: {}
  when: first_run and not is_status_display

- name: Build initial state record
  ansible.builtin.set_fact:
    first_run_changes: "{{ first_run_changes | default({}) | combine(initial_map) }}"
  vars:
    initial_entry:
      previous: '-'
      current: "{{ item.value.current }}"
      metadata: "{{ item.value.metadata }}"
    initial_map: "{{ {item.key: initial_entry} }}"
  loop: "{{ after_versions | dict2items }}"
  when: first_run and not is_status_display

- name: Add initial state to changes history (unlimited entries)
  ansible.builtin.set_fact:
    version_history: >-
      {{ version_history | combine({
        'changes': ([{
          'timestamp': current_timestamp,
          'user': current_user,
          'changes': first_run_changes,
          'event_type': 'initial'
        }] + version_history.changes)
      }) }}
  when: first_run and first_run_changes is defined and (summary_history_max_entries | int == 0) and not is_status_display

- name: Add initial state to changes history (limited entries)
  ansible.builtin.set_fact:
    version_history: >-
      {{ version_history | combine({
        'changes': ([{
          'timestamp': current_timestamp,
          'user': current_user,
          'changes': first_run_changes,
          'event_type': 'initial'
        }] + version_history.changes)[: (summary_history_max_entries | int)]
      }) }}
  when: first_run and first_run_changes is defined and (summary_history_max_entries | int > 0) and not is_status_display

# Update full history for tracking every service independently
- name: Update full history for each service (prepare update record)
  ansible.builtin.set_fact:
    current_service_entry: "{{ (version_history.full_history | default({}))[item.key] | default({}) }}"
    current_service_updates: "{{ current_service_entry.updates | default([]) }}"
    new_update_entry:
      timestamp: "{{ current_timestamp }}"
      previous: "{{ item.value.previous | default('-') }}"
      current: "{{ item.value.current }}"
      user: "{{ current_user }}"
      metadata: "{{ item.value.metadata | docker_summary_history_metadata(item.value.change_type) }}"
      change_type: "{{ item.value.change_type }}"
  loop: "{{ after_versions | dict2items }}"
  when: (has_changes or first_run) and item.value.change_type not in ['unchanged', 'status'] and not is_status_display

- name: Update full history for each service (build service record)
  ansible.builtin.set_fact:
    service_record:
      version: "{{ item.value.current }}"
      last_updated: >-
        {{
          (item.value.change_type not in ['unchanged', 'status'])
          | ternary(current_timestamp, current_service_entry.last_updated | default(current_timestamp))
        }}
      status: "{{ item.value.status }}"
      change_type: "{{ item.value.change_type }}"
      metadata: "{{ item.value.metadata | docker_summary_history_metadata(item.value.change_type) }}"
      updates: >-
        {{
          (item.value.change_type not in ['unchanged', 'status'])
          | ternary((current_service_updates + [new_update_entry])[:20], current_service_updates)
        }}
  loop: "{{ after_versions | dict2items }}"
  when: (has_changes or first_run) and item.value.change_type not in ['unchanged', 'status'] and current_service_updates is defined and not is_status_display

- name: Update full history for each service (commit to version history)
  ansible.builtin.set_fact:
    version_history: "{{ version_history | combine({'full_history': version_history.full_history | default({}) | combine({item.key: service_record})}) }}"
  loop: "{{ after_versions | dict2items }}"
  when: (has_changes or first_run) and item.value.change_type not in ['unchanged', 'status'] and service_record is defined and not is_status_display

# Record incremental changes only when not first run and changes exist
- name: Record incremental changes (unlimited entries)
  ansible.builtin.set_fact:
    version_history: >-
      {{ version_history | combine({
        'changes': ([{
          'timestamp': current_timestamp,
          'user': current_user,
          'changes': version_history_changes,
          'event_type': 'update'
        }] + version_history.changes)
      }) }}
  when: >
    has_changes and version_history_changes is defined and
    version_history_changes | length > 0 and not first_run and
    (summary_history_max_entries | int == 0) and not is_status_display

- name: Record incremental changes (limited entries)
  ansible.builtin.set_fact:
    version_history: >-
      {{ version_history | combine({
        'changes': ([{
          'timestamp': current_timestamp,
          'user': current_user,
          'changes': version_history_changes,
          'event_type': 'update'
        }] + version_history.changes)[: (summary_history_max_entries | int)]
      }) }}
  when: >
    has_changes and version_history_changes is defined and
    version_history_changes | length > 0 and not first_run and
    (summary_history_max_entries | int > 0) and not is_status_display

# Update version history with last known versions
- name: Update version history with last known versions
  ansible.builtin.set_fact:
    version_history: "{{ version_history | combine({'last_versions': current_versions, 'last_metadata': current_metadata_map}) }}"
  when: not is_status_display

# Apply date-based retention cleanup (only when retention days > 0 and not in status check mode)
# FIXED: Use cross-platform date command instead of strftime filter for reliable date calculation
- name: Calculate cutoff date for retention cleanup (Linux)
  ansible.builtin.command: date -u -d "{{ summary_retention_days }} days ago" +"%Y-%m-%d %H:%M:%S"
  register: linux_cutoff_date
  changed_when: false
  failed_when: false
  when:
    - summary_retention_days | int > 0
    - not is_status_display
    - ansible_system == "Linux"

- name: Calculate cutoff date for retention cleanup (BSD/macOS)
  ansible.builtin.command: date -u -v-{{ summary_retention_days }}d +"%Y-%m-%d %H:%M:%S"
  register: bsd_cutoff_date
  changed_when: false
  failed_when: false
  when:
    - summary_retention_days | int > 0
    - not is_status_display
    - ansible_system != "Linux"

- name: Set cutoff date based on detected OS
  ansible.builtin.set_fact:
    retention_cutoff_date: >-
      {% if ansible_system == "Linux" and linux_cutoff_date.rc is defined and linux_cutoff_date.rc == 0 %}
      {{ linux_cutoff_date.stdout }}
      {% elif ansible_system != "Linux" and bsd_cutoff_date.rc is defined and bsd_cutoff_date.rc == 0 %}
      {{ bsd_cutoff_date.stdout }}
      {% else %}
      null
      {% endif %}
  when:
    - summary_retention_days | int > 0
    - not is_status_display

- name: Log retention date calculation status
  ansible.builtin.debug:
    msg: >-
      {% if retention_cutoff_date is defined and retention_cutoff_date != 'null' %}
      Using retention cutoff date: {{ retention_cutoff_date }} (retention days: {{ summary_retention_days }})
      {% else %}
      Warning: Could not calculate retention cutoff date. Using all history entries.
      {% endif %}
    verbosity: 1
  when:
    - summary_retention_days | int > 0
    - not is_status_display

# Apply retention policy with fixed date handling
- name: Apply retention policy to changes history
  ansible.builtin.set_fact:
    version_history: "{{ version_history | combine({'changes': version_history.changes | default([]) |
        rejectattr('timestamp', 'lt', retention_cutoff_date) | list}) }}"
  when:
    - retention_cutoff_date is defined
    - retention_cutoff_date != 'null'
    - version_history.changes is defined
    - version_history.changes | length > 0
    - not is_status_display

# Set table characters based on preference
- name: Prepare table characters
  ansible.builtin.set_fact:
    summary_table_chars: "{{ docker_summary_table_style_unicode | ternary(table_chars_unicode, table_chars_ascii) }}"
    summary_table_ellipsis: "{{ docker_summary_table_style_unicode | ternary('…', '...') }}"
  vars:
    table_chars_unicode:
      h: "─"
      v: "│"
      tl: "┌"
      tr: "┐"
      bl: "└"
      br: "┘"
      t_down: "┬"
      t_up: "┴"
      t_right: "├"
      t_left: "┤"
      cross: "┼"
      double_h: "═"
      double_cross: "╪"
    table_chars_ascii:
      h: "-"
      v: "|"
      tl: "+"
      tr: "+"
      bl: "+"
      br: "+"
      t_down: "+"
      t_up: "+"
      t_right: "+"
      t_left: "+"
      cross: "+"
      double_h: "="
      double_cross: "+"
  when: after_versions | length > 0

- name: Render summary table
  vars:
    rendered_table_text: "{{ lookup('template', 'summary_table.j2') | trim }}"
  ansible.builtin.set_fact:
    version_summary_table_text: "{{ rendered_table_text }}"
    version_summary_table_lines: "{{ rendered_table_text.split('\n') }}"
  when: after_versions | length > 0

# Display table using debug for visible output
- name: Display formatted table
  ansible.builtin.debug:
    msg: "{{ version_summary_table_text }}"
  when:
    - current_versions | length > 0
    - after_versions | length > 0
    - summary_show_table | default(false) | bool

- name: Display summary suppression notice
  ansible.builtin.debug:
    msg: "Docker Ansible Summary: no changes detected for scope {{ (summary_scope_patterns_clean | length > 0) | ternary(summary_scope_patterns_clean | join(', '), 'all') }}."
  when:
    - current_versions | length > 0
    - after_versions | length > 0
    - not (summary_show_table | default(false) | bool)

# Display empty message if no containers found
- name: Display empty table message
  ansible.builtin.debug:
    msg: "Docker Ansible Summary: no containers matched scope {{ (summary_scope_patterns_clean | length > 0) | ternary(summary_scope_patterns_clean | join(', '), 'all') }}."
  when: current_versions | length == 0 or after_versions | length == 0

# Write facts to filesystem
- name: Write current versions to fact file
  ansible.builtin.copy:
    content: "{{ current_versions | to_nice_json }}"
    dest: "{{ docker_summary_facts_dir | default('/etc/ansible/facts.d') }}/{{ summary_versions_fact_file }}"
    mode: '0644'
  become: "{{ docker_summary_write_facts_become | default(true) | bool }}"
  when:
    - docker_summary_write_facts | default(true) | bool
    - not is_status_display

- name: Write version history to fact file
  ansible.builtin.copy:
    content: "{{ version_history | to_nice_json }}"
    dest: "{{ docker_summary_facts_dir | default('/etc/ansible/facts.d') }}/{{ summary_history_fact_file }}"
    mode: '0644'
  become: "{{ docker_summary_write_facts_become | default(true) | bool }}"
  when:
    - docker_summary_write_facts | default(true) | bool
    - not is_status_display

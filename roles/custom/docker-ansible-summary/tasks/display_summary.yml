# SPDX-FileCopyrightText: 2025 MDAD project contributors
# SPDX-License-Identifier: AGPL-3.0-or-later

---
# Display version summary with current states and changes

# Resolve runtime configuration from role variables
- name: Resolve summary configuration
  ansible.builtin.set_fact:
    summary_container_prefix: "{{ docker_summary_container_prefix | default('matrix-') }}"
    summary_versions_fact_file: "{{ docker_summary_versions_fact_file | default('matrix_versions.fact') }}"
    summary_history_fact_file: "{{ docker_summary_history_fact_file | default('matrix_version_history.fact') }}"
    summary_display_enabled: "{{ docker_summary_display | default(true) | bool }}"
    summary_history_max_entries: "{{ docker_summary_history_max_entries | default(100) | int }}"
    summary_retention_days: "{{ docker_summary_retention_days | default(365) | int }}"
    summary_table_style_unicode: "{{ docker_summary_table_style_unicode | default(false) | bool }}"
    summary_table_service_width: "{{ docker_summary_table_service_width | default(30) | int }}"
    summary_table_version_width: "{{ docker_summary_table_version_width | default(25) | int }}"
    summary_table_status_width: "{{ docker_summary_table_status_width | default(9) | int }}"
    summary_version_extract_smart: "{{ docker_summary_version_extract_smart | default(true) | bool }}"

# Detect execution context to determine appropriate behavior
- name: Detect execution context
  ansible.builtin.set_fact:
    status_check_mode: >-
      {{
        ansible_run_tags is defined and
        (ansible_run_tags | length == 1) and
        ((ansible_run_tags | first) == 'docker-ansible-summary')
      }}

- name: Debug execution context
  ansible.builtin.debug:
    msg: |
      ansible_run_tags: {{ ansible_run_tags | default('undefined') }}
      status_check_mode: {{ status_check_mode }}
      current_versions length: {{ current_versions | default({}) | length }}
      after_versions length: {{ after_versions | default({}) | length }}

- name: Skip version summary display if feature disabled
  ansible.builtin.meta: end_play
  when: not (summary_display_enabled | bool)

# Get container versions with improved error handling - hybrid method
- name: Discover Docker containers matching prefix
  ansible.builtin.shell: |
    set -o pipefail
    docker ps --filter "name={{ summary_container_prefix | regex_escape }}" \
      --format "{{ "{{" }}.Names{{ "}}" }}" | \
      sort || echo "DOCKER_ERROR"
  register: container_names
  changed_when: false
  failed_when: container_names.stdout == "DOCKER_ERROR"
  args:
    executable: /bin/bash
  ignore_errors: true

- name: Get detailed container image information
  ansible.builtin.shell: |
    docker inspect --format='{{ "{{" }}.Config.Image{{ "}}" }}' "{{ item }}" 2>/dev/null || echo "unknown"
  register: container_images
  loop: "{{ container_names.stdout_lines | default([]) }}"
  changed_when: false
  ignore_errors: true
  when:
    - not (container_names is failed)
    - container_names.stdout_lines is defined
    - container_names.stdout_lines | length > 0

- name: Handle Docker command failure
  ansible.builtin.debug:
    msg: "Warning: Could not retrieve Docker container information. Docker may not be running or accessible."
  when: container_names is failed

# Initialize data structures
- name: Process current versions
  ansible.builtin.set_fact:
    current_versions: {}
    after_versions: {}

# Read existing version info
- name: Read local facts if they exist
  ansible.builtin.set_fact:
    before_versions: "{{ ansible_local[(summary_versions_fact_file | regex_replace('\\.fact$', ''))] | default({}) }}"
  when: ansible_local is defined and ansible_local[(summary_versions_fact_file | regex_replace('\\.fact$', ''))] is defined

- name: Initialize before_versions if not exists
  ansible.builtin.set_fact:
    before_versions: {}
  when: before_versions is not defined

- name: Read version history if it exists
  ansible.builtin.set_fact:
    version_history: "{{ ansible_local[(summary_history_fact_file | regex_replace('\\.fact$', ''))] | default({'changes': [], 'full_history': {}}) }}"
  when: ansible_local is defined and ansible_local[(summary_history_fact_file | regex_replace('\\.fact$', ''))] is defined

- name: Initialize version history if not exists
  ansible.builtin.set_fact:
    version_history: {"last_versions": {}, "changes": [], "full_history": {}}
  when: version_history is not defined

# Process container versions with improved validation
- name: Process version changes for each service
  ansible.builtin.set_fact:
    current_versions: "{{ current_versions | combine({item_name: item_version}) }}"
  vars:
    item_name: "{{ container_names.stdout_lines[ansible_loop.index0] }}"
    full_image: "{{ item.stdout }}"
    # Extract image name without registry (e.g., element-hq/synapse from ghcr.io/element-hq/synapse:v1.96.1)
    image_name_part: "{{ full_image.split('/')[-1].split(':')[0] if '/' in full_image else full_image.split(':')[0] }}"
    # Extract version tag (e.g., v1.96.1 from ghcr.io/element-hq/synapse:v1.96.1)
    version_tag: "{{ full_image.split(':')[-1] if ':' in full_image else 'latest' }}"
    # Combine for display: image_name:version (e.g., synapse:v1.96.1) unless smart extraction disabled
    item_version: >-
      {{
        summary_version_extract_smart |
        ternary(
          image_name_part ~ ':' ~ version_tag,
          full_image
        )
      }}
  loop: "{{ container_images.results | default([]) }}"
  loop_control:
    extended: true
  when:
    - not (container_names is failed)
    - container_images.results is defined
    - container_images.results | length > 0
    - item.stdout is defined
    - item.stdout != "unknown"
    - item.stdout != ""

# Build version changes dict with status (NEW, UPDATED, UNCHANGED)
- name: Build version changes dict
  ansible.builtin.set_fact:
    after_versions: >-
      {{ after_versions | combine({
        item: {
          'current': current_versions[item],
          'previous': before_versions[item] | default(none),
          'status': 'NEW' if item not in before_versions else (
            'UPDATED' if current_versions[item] != before_versions[item] else 'UNCHANGED'
          )
        }
      }) }}
  loop: "{{ current_versions.keys() | list }}"
  when: current_versions | length > 0 and not (status_check_mode | default(false) | bool)

# In status check mode, create a status display dict without change detection
- name: Build status display dict for tag-only execution
  ansible.builtin.set_fact:
    after_versions: "{{ after_versions | combine({item: {'current': current_versions[item], 'previous': current_versions[item], 'status': 'CURRENT'}}) }}"
  loop: "{{ current_versions.keys() | list }}"
  when:
    - current_versions | length > 0
    - status_check_mode | default(false) | bool

- name: Debug after_versions after status mode building
  ansible.builtin.debug:
    msg: "after_versions after status mode: {{ after_versions | length }} items"
  when:
    - current_versions | length > 0
    - status_check_mode | default(false) | bool

# Set display and change tracking variables
- name: Set display and change tracking variables
  ansible.builtin.set_fact:
    has_changes: >-
      {{ after_versions.values() |
         selectattr('status', 'in', ['NEW', 'UPDATED']) |
         list | length > 0 }}
    first_run: "{{ before_versions.keys() | length == 0 }}"
    is_status_display: "{{ status_check_mode | default(false) | bool }}"

# Only handle history recording when not in status check mode
- name: Record changes to history when changes exist
  ansible.builtin.set_fact:
    version_history_changes: {}
  when: has_changes and not is_status_display

- name: Update history with new changes
  ansible.builtin.set_fact:
    version_history_changes: >-
      {{ version_history_changes | default({}) | combine({
        item.key: {
          'previous': item.value.previous,
          'current': item.value.current
        }
      }) }}
  loop: "{{ after_versions | dict2items }}"
  when: has_changes and item.value.status != 'UNCHANGED' and not is_status_display

- name: Get current timestamp
  ansible.builtin.set_fact:
    current_timestamp: >-
      {{ ansible_date_time.year }}-{{ ansible_date_time.month }}-{{ ansible_date_time.day }}
      {{ ansible_date_time.hour }}:{{ ansible_date_time.minute }}:{{ ansible_date_time.second }}
  when: (has_changes or first_run) and not is_status_display

- name: Get current username
  ansible.builtin.set_fact:
    current_user: "{{ ansible_user_id | default(lookup('env', 'USER') | default(lookup('env', 'USERNAME') | default('unknown'))) }}"
  when: (has_changes or first_run) and not is_status_display

# Record initial state on first run
- name: Record initial state for full history
  ansible.builtin.set_fact:
    first_run_changes: {}
  when: first_run and not is_status_display

- name: Build initial state record
  ansible.builtin.set_fact:
    first_run_changes: "{{ first_run_changes | default({}) | combine({item.key: {'previous': '-', 'current': item.value.current}}) }}"
  loop: "{{ after_versions | dict2items }}"
  when: first_run and not is_status_display

- name: Add initial state to changes history (unlimited entries)
  ansible.builtin.set_fact:
    version_history: >-
      {{ version_history | combine({
        'changes': ([{
          'timestamp': current_timestamp,
          'user': current_user,
          'changes': first_run_changes,
          'event_type': 'initial'
        }] + version_history.changes)
      }) }}
  when: first_run and first_run_changes is defined and (summary_history_max_entries | int == 0) and not is_status_display

- name: Add initial state to changes history (limited entries)
  ansible.builtin.set_fact:
    version_history: >-
      {{ version_history | combine({
        'changes': ([{
          'timestamp': current_timestamp,
          'user': current_user,
          'changes': first_run_changes,
          'event_type': 'initial'
        }] + version_history.changes)[: (summary_history_max_entries | int)]
      }) }}
  when: first_run and first_run_changes is defined and (summary_history_max_entries | int > 0) and not is_status_display

# Update full history for tracking every service independently
- name: Update full history for each service (prepare update record)
  ansible.builtin.set_fact:
    current_service_updates: "{{ version_history.full_history[item.key].updates | default([]) }}"
    new_update_entry: {
      'timestamp': "{{ current_timestamp }}",
      'previous': "{{ item.value.previous | default('-') }}",
      'current': "{{ item.value.current }}",
      'user': "{{ current_user }}"
    }
  loop: "{{ after_versions | dict2items }}"
  when: (has_changes or first_run) and item.value.status != 'UNCHANGED' and not is_status_display

- name: Update full history for each service (build service record)
  ansible.builtin.set_fact:
    service_record: {
      'version': "{{ item.value.current }}",
      'last_updated': "{{ current_timestamp if item.value.status != 'UNCHANGED' else
        (version_history.full_history[item.key].last_updated | default(current_timestamp)) }}",
      'status': "{{ item.value.status }}",
      'updates': "{{ (current_service_updates + [new_update_entry])[:20]
        if item.value.status != 'UNCHANGED' else current_service_updates }}"
    }
  loop: "{{ after_versions | dict2items }}"
  when: (has_changes or first_run) and item.value.status != 'UNCHANGED' and current_service_updates is defined and not is_status_display

- name: Update full history for each service (commit to version history)
  ansible.builtin.set_fact:
    version_history: "{{ version_history | combine({'full_history': version_history.full_history | default({}) | combine({item.key: service_record})}) }}"
  loop: "{{ after_versions | dict2items }}"
  when: (has_changes or first_run) and item.value.status != 'UNCHANGED' and service_record is defined and not is_status_display

# Record incremental changes only when not first run and changes exist
- name: Record incremental changes (unlimited entries)
  ansible.builtin.set_fact:
    version_history: >-
      {{ version_history | combine({
        'changes': ([{
          'timestamp': current_timestamp,
          'user': current_user,
          'changes': version_history_changes,
          'event_type': 'update'
        }] + version_history.changes)
      }) }}
  when: >
    has_changes and version_history_changes is defined and
    version_history_changes | length > 0 and not first_run and
    (summary_history_max_entries | int == 0) and not is_status_display

- name: Record incremental changes (limited entries)
  ansible.builtin.set_fact:
    version_history: >-
      {{ version_history | combine({
        'changes': ([{
          'timestamp': current_timestamp,
          'user': current_user,
          'changes': version_history_changes,
          'event_type': 'update'
        }] + version_history.changes)[: (summary_history_max_entries | int)]
      }) }}
  when: >
    has_changes and version_history_changes is defined and
    version_history_changes | length > 0 and not first_run and
    (summary_history_max_entries | int > 0) and not is_status_display

# Update version history with last known versions
- name: Update version history with last known versions
  ansible.builtin.set_fact:
    version_history: "{{ version_history | combine({'last_versions': current_versions}) }}"
  when: not is_status_display

# Apply date-based retention cleanup (only when retention days > 0 and not in status check mode)
# FIXED: Use cross-platform date command instead of strftime filter for reliable date calculation
- name: Calculate cutoff date for retention cleanup (Linux)
  ansible.builtin.command: date -u -d "{{ summary_retention_days }} days ago" +"%Y-%m-%d %H:%M:%S"
  register: linux_cutoff_date
  changed_when: false
  failed_when: false
  when:
    - summary_retention_days | int > 0
    - not is_status_display
    - ansible_system == "Linux"

- name: Calculate cutoff date for retention cleanup (BSD/macOS)
  ansible.builtin.command: date -u -v-{{ summary_retention_days }}d +"%Y-%m-%d %H:%M:%S"
  register: bsd_cutoff_date
  changed_when: false
  failed_when: false
  when:
    - summary_retention_days | int > 0
    - not is_status_display
    - ansible_system != "Linux"

- name: Set cutoff date based on detected OS
  ansible.builtin.set_fact:
    retention_cutoff_date: >-
      {% if ansible_system == "Linux" and linux_cutoff_date.rc is defined and linux_cutoff_date.rc == 0 %}
      {{ linux_cutoff_date.stdout }}
      {% elif ansible_system != "Linux" and bsd_cutoff_date.rc is defined and bsd_cutoff_date.rc == 0 %}
      {{ bsd_cutoff_date.stdout }}
      {% else %}
      null
      {% endif %}
  when:
    - summary_retention_days | int > 0
    - not is_status_display

- name: Log retention date calculation status
  ansible.builtin.debug:
    msg: >-
      {% if retention_cutoff_date is defined and retention_cutoff_date != 'null' %}
      Using retention cutoff date: {{ retention_cutoff_date }} (retention days: {{ summary_retention_days }})
      {% else %}
      Warning: Could not calculate retention cutoff date. Using all history entries.
      {% endif %}
  when:
    - summary_retention_days | int > 0
    - not is_status_display

# Apply retention policy with fixed date handling
- name: Apply retention policy to changes history
  ansible.builtin.set_fact:
    version_history: "{{ version_history | combine({'changes': version_history.changes | default([]) |
        rejectattr('timestamp', 'lt', retention_cutoff_date) | list}) }}"
  when:
    - retention_cutoff_date is defined
    - retention_cutoff_date != 'null'
    - version_history.changes is defined
    - version_history.changes | length > 0
    - not is_status_display

# Set table characters based on preference
- name: Set table characters (Unicode)
  ansible.builtin.set_fact:
    h_line: "─"
    v_line: "│"
    tl_corner: "┌"
    tr_corner: "┐"
    bl_corner: "└"
    br_corner: "┘"
    t_down: "┬"
    t_up: "┴"
    t_right: "├"
    t_left: "┤"
    cross: "┼"
    double_h_line: "═"
    double_cross: "╪"
  when:
    - after_versions | length > 0
    - summary_table_style_unicode | bool

- name: Set table characters (ASCII)
  ansible.builtin.set_fact:
    h_line: "-"
    v_line: "|"
    tl_corner: "+"
    tr_corner: "+"
    bl_corner: "+"
    br_corner: "+"
    t_down: "+"
    t_up: "+"
    t_right: "+"
    t_left: "+"
    cross: "+"
    double_h_line: "="
    double_cross: "+"
  when:
    - after_versions | length > 0
    - not (summary_table_style_unicode | bool)

# Build table structure with configurable column widths
- name: Create table header
  ansible.builtin.set_fact:
    service_col_width: "{{ summary_table_service_width }}"
    version_col_width: "{{ summary_table_version_width }}"
    status_col_width: "{{ summary_table_status_width }}"
    service_border_width: "{{ (summary_table_service_width | int) + 2 }}"
    version_border_width: "{{ (summary_table_version_width | int) + 2 }}"
    status_border_width: "{{ (summary_table_status_width | int) + 2 }}"
  when: after_versions | length > 0

- name: Build table lines with configurable widths
  ansible.builtin.set_fact:
    top_line: "{{ tl_corner }}{{ h_line * (service_border_width | int) }}{{ t_down }}{{ h_line * (version_border_width | int) }}{{ t_down }}{{ h_line * (version_border_width | int) }}{{ t_down }}{{ h_line * (status_border_width | int) }}{{ tr_corner }}"
    bottom_line: "{{ bl_corner }}{{ h_line * (service_border_width | int) }}{{ t_up }}{{ h_line * (version_border_width | int) }}{{ t_up }}{{ h_line * (version_border_width | int) }}{{ t_up }}{{ h_line * (status_border_width | int) }}{{ br_corner }}"

- name: Build header row with configurable widths
  ansible.builtin.set_fact:
    header_row: "{{ v_line }} {{ service_header }} {{ v_line }} {{ before_header }} {{ v_line }} {{ after_header }} {{ v_line }} {{ status_header }} {{ v_line }}"
  vars:
    service_header: "{{ ('SERVICE/CONTAINER' + ' ' * (service_col_width | int))[: service_col_width | int] }}"
    before_header: "{{ ('VERSION BEFORE' + ' ' * (version_col_width | int))[: version_col_width | int] }}"
    after_header: "{{ ('VERSION AFTER' + ' ' * (version_col_width | int))[: version_col_width | int] }}"
    status_header: "{{ ('STATUS' + ' ' * (status_col_width | int))[: status_col_width | int] }}"

- name: Build header separator with configurable widths
  ansible.builtin.set_fact:
    header_sep: "{{ t_right }}{{ double_h_line * (service_border_width | int) }}{{ double_cross }}{{ double_h_line * (version_border_width | int) }}{{ double_cross }}{{ double_h_line * (version_border_width | int) }}{{ double_cross }}{{ double_h_line * (status_border_width | int) }}{{ t_left }}"
  when: after_versions | length > 0

# Generate table rows
- name: Generate table content
  ansible.builtin.set_fact:
    table_rows: []
  when: after_versions | length > 0

- name: Add table rows
  ansible.builtin.set_fact:
    table_rows: "{{ table_rows + [table_row] }}"
  vars:
    table_row: >-
      {{ v_line + ' ' +
         ((item.key | truncate(service_col_width | int, true)) + ' ' * (service_col_width | int))[:service_col_width | int] + ' ' +
         v_line + ' ' +
         (((item.value.previous | default('-') | string | truncate(version_col_width | int, true)) +
         ' ' * (version_col_width | int))[:version_col_width | int]) + ' ' +
         v_line + ' ' +
         (((item.value.current | string | truncate(version_col_width | int, true)) +
         ' ' * (version_col_width | int))[:version_col_width | int]) + ' ' +
         v_line + ' ' +
         ((item.value.status + ' ' * (status_col_width | int))[:status_col_width | int]) + ' ' +
         v_line }}
  loop: "{{ after_versions | dict2items | sort(attribute='key') }}"
  when: after_versions | length > 0

# Create complete table output as list of lines
- name: Build complete table as list
  ansible.builtin.set_fact:
    version_summary_table_lines: >-
      {{ ['DOCKER SERVICE VERSION CHANGES - ' + ansible_date_time.iso8601, ''] +
         [top_line, header_row, header_sep] +
         table_rows +
         [bottom_line, '', 'Total containers discovered: ' + (after_versions | length | string), ''] +
         (['[CURRENT STATUS DISPLAY - NO CHANGES RECORDED]'] if is_status_display
          else ['[NEW VERSION CHANGES RECORDED]'] if has_changes
          else ['[INITIAL STATE RECORDED]'] if first_run
          else ['[NO CHANGES DETECTED]']) }}
  when: after_versions | length > 0

# Display table using debug for visible output
- name: Display formatted table
  ansible.builtin.debug:
    msg: "{{ version_summary_table_lines }}"
  when:
    - current_versions | length > 0
    - after_versions | length > 0

# Display empty message if no containers found
- name: Display empty table message
  ansible.builtin.debug:
    msg: >-
      {{ ['DOCKER SERVICE VERSION CHANGES - ' + ansible_date_time.iso8601, '',
         'No matching containers found running. ' +
         ('In status check mode - showing current state only.' if is_status_display
          else 'Start services first to see version information.')] }}
  when: current_versions | length == 0 or after_versions | length == 0

# Write facts to filesystem
- name: Write current versions to fact file
  ansible.builtin.copy:
    content: "{{ current_versions | to_nice_json }}"
    dest: "/etc/ansible/facts.d/{{ summary_versions_fact_file }}"
    mode: '0644'
  become: true
  when: not is_status_display

- name: Write version history to fact file
  ansible.builtin.copy:
    content: "{{ version_history | to_nice_json }}"
    dest: "/etc/ansible/facts.d/{{ summary_history_fact_file }}"
    mode: '0644'
  become: true
  when: not is_status_display

# SPDX-FileCopyrightText: 2025 MDAD project contributors
# SPDX-License-Identifier: AGPL-3.0-or-later

---
# Display version summary with current states and changes

# Resolve runtime configuration from role variables
- name: Resolve summary configuration
  ansible.builtin.set_fact:
    summary_scope_value: "{{ docker_summary_scope | default('matrix-*') }}"
    summary_versions_fact_file: "{{ docker_summary_versions_fact_file | default('matrix_versions.fact') }}"
    summary_versions_fact_key: "{{ (docker_summary_versions_fact_file | default('matrix_versions.fact')) | regex_replace('\\.fact$', '') }}"
    summary_history_fact_file: "{{ docker_summary_history_fact_file | default('matrix_version_history.fact') }}"
    summary_history_fact_key: "{{ (docker_summary_history_fact_file | default('matrix_version_history.fact')) | regex_replace('\\.fact$', '') }}"
    summary_display_enabled: "{{ docker_summary_display | default(true) | bool }}"
    summary_history_max_entries: "{{ docker_summary_history_max_entries | default(100) | int }}"
    summary_retention_days: "{{ docker_summary_retention_days | default(365) | int }}"
    summary_table_style_unicode: "{{ docker_summary_table_style_unicode | default(false) | bool }}"
    summary_table_service_width: "{{ docker_summary_table_service_width | default(30) | int }}"
    summary_table_version_width: "{{ docker_summary_table_version_width | default(25) | int }}"
    summary_table_status_width: "{{ docker_summary_table_status_width | default(9) | int }}"
    summary_version_extract_smart: "{{ docker_summary_version_extract_smart | default(true) | bool }}"

# Detect execution context to determine appropriate behavior
- name: Detect execution context
  ansible.builtin.set_fact:
    status_check_mode: >-
      {{
        ansible_run_tags is defined and
        (ansible_run_tags | length == 1) and
        ((ansible_run_tags | first) == 'docker-ansible-summary')
      }}

- name: Debug execution context
  ansible.builtin.debug:
    msg: |
      ansible_run_tags: {{ ansible_run_tags | default('undefined') }}
      status_check_mode: {{ status_check_mode }}
      current_versions length: {{ current_versions | default({}) | length }}
      after_versions length: {{ after_versions | default({}) | length }}

- name: Skip version summary display if feature disabled
  ansible.builtin.meta: end_play
  when: not (summary_display_enabled | bool)

# Get container list (name + image) with improved error handling
- name: Discover Docker containers
  ansible.builtin.shell: |
    set -o pipefail
    docker ps --format '{% raw %}{{.Names}}||{{.Image}}{% endraw %}' | \
      sort || echo "DOCKER_ERROR"
  register: container_list
  changed_when: false
  failed_when: container_list.stdout == "DOCKER_ERROR"
  args:
    executable: /bin/bash
  ignore_errors: true
  when: docker_summary_container_overrides | length == 0

- name: Handle Docker command failure
  ansible.builtin.debug:
    msg: "Warning: Could not retrieve Docker container information. Docker may not be running or accessible."
  when:
    - container_list is defined
    - container_list is failed

- name: Determine discovery availability
  ansible.builtin.set_fact:
    summary_discovery_available: >-
      {{
        (docker_summary_container_overrides | length > 0) or
        (container_list is defined and not (container_list is failed))
      }}

- name: Initialize container catalogue
  ansible.builtin.set_fact:
    all_containers: []
    filtered_containers: []
    container_inspect_map: {}
    current_metadata_map: {}
    summary_skip_processing: false
    summary_skip_reason: ""

- name: Seed container catalogue from provided overrides
  ansible.builtin.set_fact:
    all_containers: "{{ docker_summary_container_overrides | map('combine', {}) | list }}"
  when: docker_summary_container_overrides | length > 0

- name: Seed inspect data from overrides
  ansible.builtin.set_fact:
    container_inspect_map: "{{ container_inspect_map | combine({item.name: item.inspect}) }}"
  loop: "{{ docker_summary_container_overrides }}"
  when:
    - docker_summary_container_overrides | length > 0
    - item.inspect is defined

- name: Build container catalogue
  ansible.builtin.set_fact:
    all_containers: "{{ all_containers + [{'name': item_parts[0], 'image': item_parts[1]}] }}"
  vars:
    item_parts: "{{ item.split('||', 1) }}"
  loop: "{{ container_list.stdout_lines | default([]) }}"
  when:
    - docker_summary_container_overrides | length == 0
    - container_list is defined
    - not (container_list is failed)
    - item is defined
    - item_parts | length == 2

- name: Normalize scope configuration
  ansible.builtin.set_fact:
    summary_scope_patterns_clean: "{{ summary_scope_value | docker_scope_patterns }}"
    summary_scope_all: "{{ summary_scope_value | docker_scope_all }}"

- name: Apply container scope
  ansible.builtin.set_fact:
    filtered_containers: "{{ all_containers | docker_scope_filter(summary_scope_value) }}"
  when: summary_discovery_available | default(false) | bool

# Initialize data structures
- name: Process current versions
  ansible.builtin.set_fact:
    current_versions: {}
    after_versions: {}

- name: Resolve cached local facts
  ansible.builtin.set_fact:
    summary_local_facts: "{{ (docker_summary_ansible_local_override if docker_summary_ansible_local_override is not none else ansible_local) | default({}) }}"

# Read existing version info
- name: Read local facts if they exist
  ansible.builtin.set_fact:
    before_versions: "{{ summary_local_facts[summary_versions_fact_key] | default({}) }}"
  when: summary_local_facts is mapping and summary_versions_fact_key in summary_local_facts

- name: Initialize before_versions if not exists
  ansible.builtin.set_fact:
    before_versions: {}
  when: before_versions is not defined

- name: Normalise previous versions structure
  ansible.builtin.set_fact:
    before_versions: "{{ before_versions if (before_versions is mapping) else (before_versions | default('{}') | from_yaml) }}"

- name: Read version history if it exists
  ansible.builtin.set_fact:
    version_history: "{{ summary_local_facts[summary_history_fact_key] | default({'changes': [], 'full_history': {}}) }}"
  when: summary_local_facts is mapping and summary_history_fact_key in summary_local_facts

- name: Initialize version history if not exists
  ansible.builtin.set_fact:
    version_history: {"last_versions": {}, "changes": [], "full_history": {}}
  when: version_history is not defined

- name: Ensure version history metadata containers exist
  ansible.builtin.set_fact:
    version_history: "{{ version_history | combine({'last_metadata': version_history.last_metadata | default({})}, recursive=True) }}"

- name: Capture previous metadata snapshot
  ansible.builtin.set_fact:
    before_metadata: "{{ version_history.last_metadata | default({}) }}"

- name: Normalise previous metadata structure
  ansible.builtin.set_fact:
    before_metadata: "{{ before_metadata if (before_metadata is mapping) else (before_metadata | default('{}') | from_yaml) }}"

- name: Filter previous versions to current scope
  ansible.builtin.set_fact:
    before_versions: "{{ before_versions | docker_scope_filter_dict(summary_scope_value) }}"
  when: before_versions is defined

- name: Filter previous metadata to current scope
  ansible.builtin.set_fact:
    before_metadata: "{{ before_metadata | docker_scope_filter_dict(summary_scope_value) }}"
  when: before_metadata is defined

- name: Capture list of previously-known services
  ansible.builtin.set_fact:
    summary_known_services: "{{ before_versions | default({}) | dict2items | map(attribute='key') | list }}"

- name: Determine first run state
  ansible.builtin.set_fact:
    summary_first_run: "{{ summary_known_services | length == 0 }}"

- name: Flag discovery failure when Docker command fails
  ansible.builtin.set_fact:
    summary_skip_processing: true
    summary_skip_reason: "docker_command_failed"
  when:
    - container_list is defined
    - container_list is failed

- name: Explain skipped summary processing
  ansible.builtin.debug:
    msg: >-
      Docker Ansible Summary skipped: Docker CLI command failed; leaving previous facts untouched.
  when: summary_skip_processing | bool

- name: Abort summary processing when prerequisites are missing
  ansible.builtin.meta: end_play
  when: summary_skip_processing | bool

# Process container versions with improved validation
- name: Process version changes for each service
  ansible.builtin.set_fact:
    current_versions: "{{ current_versions | combine({item_name: item_version}) }}"
    current_metadata_map: "{{ current_metadata_map | combine({item_name: metadata_details}) }}"
  vars:
    item_name: "{{ item.name }}"
    full_image: "{{ item.image }}"
    image_name_part: "{{ full_image.split('/')[-1].split(':')[0] if '/' in full_image else full_image.split(':')[0] }}"
    version_tag: "{{ full_image.split(':')[-1] if ':' in full_image else 'latest' }}"
    inspect_data: "{{ container_inspect_map[item_name] | default({}) }}"
    metadata_details: {
      'image': "{{ full_image }}",
      'image_id': "{{ inspect_data.Image | default('') }}",
      'repo_digest': "{{ (inspect_data.RepoDigests | default([])) | first | default('') }}",
      'created': "{{ inspect_data.Created | default('') }}",
      'state': {
        'status': "{{ inspect_data.State.Status | default('unknown') }}",
        'running': "{{ inspect_data.State.Running | default(false) }}",
        'started_at': "{{ inspect_data.State.StartedAt | default('') }}",
        'finished_at': "{{ inspect_data.State.FinishedAt | default('') }}",
        'exit_code': "{{ inspect_data.State.ExitCode | default(none) }}",
        'restart_count': "{{ inspect_data.RestartCount | default(0) }}"
      }
    }
    item_version: >-
      {{
        summary_version_extract_smart |
        ternary(
          image_name_part ~ ':' ~ version_tag,
          full_image
        )
      }}
  loop: "{{ filtered_containers }}"
  when:
    - filtered_containers | length > 0

# Build version changes dict with change tracking metadata
- name: Build version changes dict
  ansible.builtin.set_fact:
    after_versions: >-
      {{ after_versions | combine({
        item: {
          'current': current_versions[item],
          'previous': before_versions.get(item),
          'status': status_value,
          'change_type': change_type,
          'metadata': {
            'current': current_metadata_map[item] | default({}),
            'previous': before_metadata.get(item, {})
          }
        }
      }) }}
  vars:
    change_type: "{{ summary_first_run | ternary('baseline', (item not in before_versions) | ternary('added', (current_versions[item] != before_versions.get(item)) | ternary('updated', 'unchanged'))) }}"
    status_value: "{{ 'BASELINE' if change_type == 'baseline' else ('UNCHANGED' if change_type == 'unchanged' else 'CHANGED') }}"
  loop: "{{ current_versions.keys() | list }}"
  when: current_versions | length > 0 and not (status_check_mode | default(false) | bool)

# In status check mode, create a status display dict without change detection
- name: Build status display dict for tag-only execution
  ansible.builtin.set_fact:
    after_versions: "{{ after_versions | combine({item: {'current': current_versions[item], 'previous': current_versions[item], 'status': 'CURRENT', 'change_type': 'status', 'metadata': {'current': current_metadata_map[item] | default({}), 'previous': current_metadata_map[item] | default({})}}}) }}"
  loop: "{{ current_versions.keys() | list }}"
  when:
    - current_versions | length > 0
    - status_check_mode | default(false) | bool

- name: Debug after_versions after status mode building
  ansible.builtin.debug:
    msg: "after_versions after status mode: {{ after_versions | length }} items"
  when:
    - current_versions | length > 0
    - status_check_mode | default(false) | bool

- name: Add removed services to summary (normal mode)
  ansible.builtin.set_fact:
    after_versions: >-
      {{ after_versions | combine({
        item: {
          'current': '(removed)',
          'previous': before_versions.get(item),
          'status': 'CHANGED',
          'change_type': 'removed',
          'metadata': {
            'current': {},
            'previous': before_metadata.get(item, {})
          }
        }
      }) }}
  loop: "{{ before_versions.keys() | list }}"
  when:
    - not (status_check_mode | default(false) | bool)
    - before_versions | length > 0
    - item not in current_versions

- name: Build status labels for output
  ansible.builtin.set_fact:
    after_versions: >-
      {{ after_versions | combine({
        item.key: item.value | combine({'status_label': status_label})
      }) }}
  vars:
    status_label: "{{ (item.value.change_type in ['added', 'updated', 'removed']) | ternary(item.value.status ~ ' (' ~ (item.value.change_type | upper) ~ ')', (item.value.change_type == 'baseline') | ternary(item.value.status ~ ' (INITIAL)', item.value.status)) }}"
  loop: "{{ after_versions | dict2items }}"

# Set display and change tracking variables
- name: Set display and change tracking variables
  ansible.builtin.set_fact:
    has_changes: >-
      {{ after_versions.values() |
         selectattr('change_type', 'in', ['added', 'updated', 'removed']) |
         list | length > 0 }}
    first_run: "{{ summary_first_run | default(false) }}"
    is_status_display: "{{ status_check_mode | default(false) | bool }}"

# Only handle history recording when not in status check mode
- name: Record changes to history when changes exist
  ansible.builtin.set_fact:
    version_history_changes: {}
  when: has_changes and not is_status_display

- name: Update history with new changes
  ansible.builtin.set_fact:
    version_history_changes: >-
      {{ version_history_changes | default({}) | combine({
        item.key: {
          'previous': item.value.previous,
          'current': item.value.current,
          'metadata': item.value.metadata
        }
      }) }}
  loop: "{{ after_versions | dict2items }}"
  when: has_changes and item.value.change_type not in ['unchanged', 'status'] and not is_status_display

- name: Get current timestamp
  ansible.builtin.set_fact:
    current_timestamp: >-
      {{ ansible_date_time.year }}-{{ ansible_date_time.month }}-{{ ansible_date_time.day }}
      {{ ansible_date_time.hour }}:{{ ansible_date_time.minute }}:{{ ansible_date_time.second }}
  when: (has_changes or first_run) and not is_status_display

- name: Get current username
  ansible.builtin.set_fact:
    current_user: "{{ ansible_user_id | default(lookup('env', 'USER') | default(lookup('env', 'USERNAME') | default('unknown'))) }}"
  when: (has_changes or first_run) and not is_status_display

# Record initial state on first run
- name: Record initial state for full history
  ansible.builtin.set_fact:
    first_run_changes: {}
  when: first_run and not is_status_display

- name: Build initial state record
  ansible.builtin.set_fact:
    first_run_changes: "{{ first_run_changes | default({}) | combine({item.key: {'previous': '-', 'current': item.value.current, 'metadata': item.value.metadata}}) }}"
  loop: "{{ after_versions | dict2items }}"
  when: first_run and not is_status_display

- name: Add initial state to changes history (unlimited entries)
  ansible.builtin.set_fact:
    version_history: >-
      {{ version_history | combine({
        'changes': ([{
          'timestamp': current_timestamp,
          'user': current_user,
          'changes': first_run_changes,
          'event_type': 'initial'
        }] + version_history.changes)
      }) }}
  when: first_run and first_run_changes is defined and (summary_history_max_entries | int == 0) and not is_status_display

- name: Add initial state to changes history (limited entries)
  ansible.builtin.set_fact:
    version_history: >-
      {{ version_history | combine({
        'changes': ([{
          'timestamp': current_timestamp,
          'user': current_user,
          'changes': first_run_changes,
          'event_type': 'initial'
        }] + version_history.changes)[: (summary_history_max_entries | int)]
      }) }}
  when: first_run and first_run_changes is defined and (summary_history_max_entries | int > 0) and not is_status_display

# Update full history for tracking every service independently
- name: Update full history for each service (prepare update record)
  ansible.builtin.set_fact:
    current_service_entry: "{{ (version_history.full_history | default({}))[item.key] | default({}) }}"
    current_service_updates: "{{ current_service_entry.updates | default([]) }}"
    new_update_entry: {
      'timestamp': "{{ current_timestamp }}",
      'previous': "{{ item.value.previous | default('-') }}",
      'current': "{{ item.value.current }}",
      'user': "{{ current_user }}",
      'metadata': "{{ (item.value.change_type == 'removed') | ternary(item.value.metadata.previous | default({}), item.value.metadata.current | default({})) }}",
      'change_type': "{{ item.value.change_type }}"
    }
  loop: "{{ after_versions | dict2items }}"
  when: (has_changes or first_run) and item.value.change_type not in ['unchanged', 'status'] and not is_status_display

- name: Update full history for each service (build service record)
  ansible.builtin.set_fact:
    service_record: {
      'version': "{{ item.value.current }}",
      'last_updated': "{{ current_timestamp if item.value.change_type not in ['unchanged', 'status'] else
        (current_service_entry.last_updated | default(current_timestamp)) }}",
      'status': "{{ item.value.status }}",
      'change_type': "{{ item.value.change_type }}",
      'metadata': "{{ (item.value.change_type == 'removed') | ternary(item.value.metadata.previous | default({}), item.value.metadata.current | default({})) }}",
      'updates': "{{ (current_service_updates + [new_update_entry])[:20]
        if item.value.change_type not in ['unchanged', 'status'] else current_service_updates }}"
    }
  loop: "{{ after_versions | dict2items }}"
  when: (has_changes or first_run) and item.value.change_type not in ['unchanged', 'status'] and current_service_updates is defined and not is_status_display

- name: Update full history for each service (commit to version history)
  ansible.builtin.set_fact:
    version_history: "{{ version_history | combine({'full_history': version_history.full_history | default({}) | combine({item.key: service_record})}) }}"
  loop: "{{ after_versions | dict2items }}"
  when: (has_changes or first_run) and item.value.change_type not in ['unchanged', 'status'] and service_record is defined and not is_status_display

# Record incremental changes only when not first run and changes exist
- name: Record incremental changes (unlimited entries)
  ansible.builtin.set_fact:
    version_history: >-
      {{ version_history | combine({
        'changes': ([{
          'timestamp': current_timestamp,
          'user': current_user,
          'changes': version_history_changes,
          'event_type': 'update'
        }] + version_history.changes)
      }) }}
  when: >
    has_changes and version_history_changes is defined and
    version_history_changes | length > 0 and not first_run and
    (summary_history_max_entries | int == 0) and not is_status_display

- name: Record incremental changes (limited entries)
  ansible.builtin.set_fact:
    version_history: >-
      {{ version_history | combine({
        'changes': ([{
          'timestamp': current_timestamp,
          'user': current_user,
          'changes': version_history_changes,
          'event_type': 'update'
        }] + version_history.changes)[: (summary_history_max_entries | int)]
      }) }}
  when: >
    has_changes and version_history_changes is defined and
    version_history_changes | length > 0 and not first_run and
    (summary_history_max_entries | int > 0) and not is_status_display

# Update version history with last known versions
- name: Update version history with last known versions
  ansible.builtin.set_fact:
    version_history: "{{ version_history | combine({'last_versions': current_versions, 'last_metadata': current_metadata_map}) }}"
  when: not is_status_display

# Apply date-based retention cleanup (only when retention days > 0 and not in status check mode)
# FIXED: Use cross-platform date command instead of strftime filter for reliable date calculation
- name: Calculate cutoff date for retention cleanup (Linux)
  ansible.builtin.command: date -u -d "{{ summary_retention_days }} days ago" +"%Y-%m-%d %H:%M:%S"
  register: linux_cutoff_date
  changed_when: false
  failed_when: false
  when:
    - summary_retention_days | int > 0
    - not is_status_display
    - ansible_system == "Linux"

- name: Calculate cutoff date for retention cleanup (BSD/macOS)
  ansible.builtin.command: date -u -v-{{ summary_retention_days }}d +"%Y-%m-%d %H:%M:%S"
  register: bsd_cutoff_date
  changed_when: false
  failed_when: false
  when:
    - summary_retention_days | int > 0
    - not is_status_display
    - ansible_system != "Linux"

- name: Set cutoff date based on detected OS
  ansible.builtin.set_fact:
    retention_cutoff_date: >-
      {% if ansible_system == "Linux" and linux_cutoff_date.rc is defined and linux_cutoff_date.rc == 0 %}
      {{ linux_cutoff_date.stdout }}
      {% elif ansible_system != "Linux" and bsd_cutoff_date.rc is defined and bsd_cutoff_date.rc == 0 %}
      {{ bsd_cutoff_date.stdout }}
      {% else %}
      null
      {% endif %}
  when:
    - summary_retention_days | int > 0
    - not is_status_display

- name: Log retention date calculation status
  ansible.builtin.debug:
    msg: >-
      {% if retention_cutoff_date is defined and retention_cutoff_date != 'null' %}
      Using retention cutoff date: {{ retention_cutoff_date }} (retention days: {{ summary_retention_days }})
      {% else %}
      Warning: Could not calculate retention cutoff date. Using all history entries.
      {% endif %}
  when:
    - summary_retention_days | int > 0
    - not is_status_display

# Apply retention policy with fixed date handling
- name: Apply retention policy to changes history
  ansible.builtin.set_fact:
    version_history: "{{ version_history | combine({'changes': version_history.changes | default([]) |
        rejectattr('timestamp', 'lt', retention_cutoff_date) | list}) }}"
  when:
    - retention_cutoff_date is defined
    - retention_cutoff_date != 'null'
    - version_history.changes is defined
    - version_history.changes | length > 0
    - not is_status_display

# Set table characters based on preference
- name: Prepare table characters
  ansible.builtin.set_fact:
    summary_table_chars: "{{ docker_summary_table_style_unicode | ternary(table_chars_unicode, table_chars_ascii) }}"
  vars:
    table_chars_unicode:
      h: "─"
      v: "│"
      tl: "┌"
      tr: "┐"
      bl: "└"
      br: "┘"
      t_down: "┬"
      t_up: "┴"
      t_right: "├"
      t_left: "┤"
      cross: "┼"
      double_h: "═"
      double_cross: "╪"
    table_chars_ascii:
      h: "-"
      v: "|"
      tl: "+"
      tr: "+"
      bl: "+"
      br: "+"
      t_down: "+"
      t_up: "+"
      t_right: "+"
      t_left: "+"
      cross: "+"
      double_h: "="
      double_cross: "+"
  when: after_versions | length > 0

- name: Render summary table
  ansible.builtin.set_fact:
    version_summary_table_lines: "{{ lookup('template', 'summary_table.j2', convert_data=False).split('
') }}"
  when: after_versions | length > 0

# Display table using debug for visible output
- name: Display formatted table
  ansible.builtin.debug:
    msg: "{{ version_summary_table_lines }}"
  when:
    - current_versions | length > 0
    - after_versions | length > 0

# Display empty message if no containers found
- name: Display empty table message
  ansible.builtin.debug:
    msg: >-
      {{ ['DOCKER SERVICE VERSION CHANGES - ' + ansible_date_time.iso8601, '',
         'No containers matched docker_summary_scope (' +
         ((summary_scope_patterns_clean | length > 0)
            | ternary(summary_scope_patterns_clean | join(', '), 'all')) + '). ' +
         ('In status check mode - showing current state only.' if is_status_display
          else 'Adjust the scope or start services to see version information.')] }}
  when: current_versions | length == 0 or after_versions | length == 0

# Write facts to filesystem
- name: Write current versions to fact file
  ansible.builtin.copy:
    content: "{{ current_versions | to_nice_json }}"
    dest: "/etc/ansible/facts.d/{{ summary_versions_fact_file }}"
    mode: '0644'
  become: true
  when:
    - docker_summary_write_facts | default(true) | bool
    - not is_status_display

- name: Write version history to fact file
  ansible.builtin.copy:
    content: "{{ version_history | to_nice_json }}"
    dest: "/etc/ansible/facts.d/{{ summary_history_fact_file }}"
    mode: '0644'
  become: true
  when:
    - docker_summary_write_facts | default(true) | bool
    - not is_status_display
- name: Gather container inspect data
  community.docker.docker_container_info:
    name: "{{ filtered_containers | map(attribute='name') | list }}"
  register: docker_container_info
  when:
    - docker_summary_container_overrides | length == 0
    - summary_discovery_available | default(false) | bool
    - filtered_containers | length > 0

- name: Build container metadata map
  ansible.builtin.set_fact:
    container_inspect_map: "{{ container_inspect_map | combine({(item.Name | default('') | regex_replace('^/', '')): item}) }}"
  loop: "{{ docker_container_info.containers | default([]) }}"
  when:
    - docker_summary_container_overrides | length == 0

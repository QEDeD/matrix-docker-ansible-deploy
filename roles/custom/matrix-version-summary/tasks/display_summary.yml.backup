---
# Display version summary with current states and changes

# Set default variables to prevent undefined variable errors
- name: Set default variables
  ansible.builtin.set_fact:
    matrix_container_prefix: "{{ matrix_container_prefix | default('matrix-') }}"
    matrix_versions_fact_file: "{{ matrix_versions_fact_file | default('matrix_versions.fact') }}"
    matrix_history_fact_file: "{{ matrix_history_fact_file | default('matrix_version_history.fact') }}"
    matrix_show_version_summary: "{{ matrix_show_version_summary | default(true) | bool }}"
    matrix_history_max_entries: "{{ matrix_history_max_entries | default(100) | int }}"
    matrix_history_retention_days: "{{ matrix_history_retention_days | default(365) | int }}"
    matrix_table_style_unicode: "{{ matrix_table_style_unicode | default(false) | bool }}"

# Detect execution context to determine appropriate behavior
- name: Detect execution context
  ansible.builtin.set_fact:
    status_check_mode: "{{ ansible_run_tags is defined and ('matrix-version-summary' in ansible_run_tags) and (ansible_run_tags | length == 1) }}"

- name: Skip version summary display if feature disabled
  ansible.builtin.meta: end_play
  when: not matrix_version_summary_display | default(matrix_show_version_summary) | bool

# Get container versions with improved error handling
- name: Get current container versions (matrix containers only)
  ansible.builtin.shell: |
    set -o pipefail
    docker ps --filter "name={{ matrix_container_prefix | regex_escape }}" \
      --format "{{ "{{" }}.Names{{ "}}" }}:{{ "{{" }}.Image{{ "}}" }}" | \
      sort || echo "DOCKER_ERROR"
  register: container_versions
  changed_when: false
  failed_when: container_versions.stdout == "DOCKER_ERROR"
  args:
    executable: /bin/bash
  ignore_errors: true

- name: Handle Docker command failure
  ansible.builtin.debug:
    msg: "Warning: Could not retrieve Docker container information. Docker may not be running or accessible."
  when: container_versions is failed

# Initialize data structures
- name: Process current versions
  ansible.builtin.set_fact:
    current_versions: {}
    after_versions: {}

# Read existing version info
- name: Read local facts if they exist
  ansible.builtin.set_fact:
    before_versions: "{{ ansible_local[(matrix_versions_fact_file | regex_replace('\\.fact$', ''))] | default({}) }}"
  when: ansible_local is defined and ansible_local[(matrix_versions_fact_file | regex_replace('\\.fact$', ''))] is defined

- name: Initialize before_versions if not exists
  ansible.builtin.set_fact:
    before_versions: {}
  when: before_versions is not defined

- name: Read version history if it exists
  ansible.builtin.set_fact:
    version_history: "{{ ansible_local[(matrix_history_fact_file | regex_replace('\\.fact$', ''))] | default({'changes': [], 'full_history': {}}) }}"
  when: ansible_local is defined and ansible_local[(matrix_history_fact_file | regex_replace('\\.fact$', ''))] is defined

- name: Initialize version history if not exists
  ansible.builtin.set_fact:
    version_history: {"last_versions": {}, "changes": [], "full_history": {}}
  when: version_history is not defined

# Process container versions with improved validation
- name: Process version changes for each service
  ansible.builtin.set_fact:
    current_versions: "{{ current_versions | combine({item.split(':')[0]: item.split(':')[1:] | join(':')}) }}"
  loop: "{{ container_versions.stdout_lines | default([]) }}"
  loop_control:
    loop_var: item
  when:
    - not (container_versions is failed)
    - container_versions.stdout_lines is defined
    - container_versions.stdout_lines | length > 0
    - "':' in item"  # Ensure the container line has the expected format
    - item.split(':') | length >= 2  # Ensure we have both name and image

# Build version changes dict with status (NEW, UPDATED, UNCHANGED)
- name: Build version changes dict
  ansible.builtin.set_fact:
    after_versions: >-
      {{ after_versions | combine({
        item: {
          'current': current_versions[item],
          'previous': before_versions[item] | default(none),
          'status': 'NEW' if item not in before_versions else (
            'UPDATED' if current_versions[item] != before_versions[item] else 'UNCHANGED'
          )
        }
      }) }}
  loop: "{{ current_versions.keys() | list }}"
  when: current_versions | length > 0 and not (status_check_mode | default(false) | bool)

# In status check mode, create a status display dict without change detection
- name: Build status display dict for tag-only execution
  ansible.builtin.set_fact:
    after_versions: "{{ after_versions | combine({item: {'current': current_versions[item], 'previous': current_versions[item], 'status': 'CURRENT'}}) }}"
  loop: "{{ current_versions.keys() | list }}"
  when:
    - current_versions | length > 0
    - status_check_mode | default(false) | bool

# Set display and change tracking variables
- name: Set display and change tracking variables
  ansible.builtin.set_fact:
    has_changes: >-
      {{ after_versions.values() |
         selectattr('status', 'in', ['NEW', 'UPDATED']) |
         list | length > 0 }}
    first_run: "{{ before_versions.keys() | length == 0 }}"
    is_status_display: "{{ status_check_mode | default(false) | bool }}"

# Only handle history recording when not in status check mode
- name: Record changes to history when changes exist
  ansible.builtin.set_fact:
    version_history_changes: {}
  when: has_changes and not is_status_display

- name: Update history with new changes
  ansible.builtin.set_fact:
    version_history_changes: >-
      {{ version_history_changes | default({}) | combine({
        item.key: {
          'previous': item.value.previous,
          'current': item.value.current
        }
      }) }}
  loop: "{{ after_versions | dict2items }}"
  when: has_changes and item.value.status != 'UNCHANGED' and not is_status_display

- name: Get current timestamp
  ansible.builtin.set_fact:
    current_timestamp: >-
      {{ ansible_date_time.year }}-{{ ansible_date_time.month }}-{{ ansible_date_time.day }}
      {{ ansible_date_time.hour }}:{{ ansible_date_time.minute }}:{{ ansible_date_time.second }}
  when: (has_changes or first_run) and not is_status_display

- name: Get current username
  ansible.builtin.set_fact:
    current_user: "{{ ansible_user_id | default(lookup('env', 'USER') | default(lookup('env', 'USERNAME') | default('unknown'))) }}"
  when: (has_changes or first_run) and not is_status_display

# Record initial state on first run
- name: Record initial state for full history
  ansible.builtin.set_fact:
    first_run_changes: {}
  when: first_run and not is_status_display

- name: Build initial state record
  ansible.builtin.set_fact:
    first_run_changes: "{{ first_run_changes | default({}) | combine({item.key: {'previous': '-', 'current': item.value.current}}) }}"
  loop: "{{ after_versions | dict2items }}"
  when: first_run and not is_status_display

- name: Add initial state to changes history (unlimited entries)
  ansible.builtin.set_fact:
    version_history: >-
      {{ version_history | combine({
        'changes': ([{
          'timestamp': current_timestamp,
          'user': current_user,
          'changes': first_run_changes,
          'event_type': 'initial'
        }] + version_history.changes)
      }) }}
  when: first_run and first_run_changes is defined and (matrix_history_max_entries | int == 0) and not is_status_display

- name: Add initial state to changes history (limited entries)
  ansible.builtin.set_fact:
    version_history: >-
      {{ version_history | combine({
        'changes': ([{
          'timestamp': current_timestamp,
          'user': current_user,
          'changes': first_run_changes,
          'event_type': 'initial'
        }] + version_history.changes)[: matrix_history_max_entries | int]
      }) }}
  when: first_run and first_run_changes is defined and (matrix_history_max_entries | int > 0) and not is_status_display

# Update full history for tracking every service independently
- name: Update full history for each service (prepare update record)
  ansible.builtin.set_fact:
    current_service_updates: "{{ version_history.full_history[item.key].updates | default([]) }}"
    new_update_entry: {
      'timestamp': "{{ current_timestamp }}",
      'previous': "{{ item.value.previous | default('-') }}",
      'current': "{{ item.value.current }}",
      'user': "{{ current_user }}"
    }
  loop: "{{ after_versions | dict2items }}"
  when: (has_changes or first_run) and item.value.status != 'UNCHANGED' and not is_status_display

- name: Update full history for each service (build service record)
  ansible.builtin.set_fact:
    service_record: {
      'version': "{{ item.value.current }}",
      'last_updated': >-
        {{ current_timestamp if item.value.status != 'UNCHANGED' else 
           (version_history.full_history[item.key].last_updated | default(current_timestamp)) }},
      'status': "{{ item.value.status }}",
      'updates': >-
        {{ (current_service_updates + [new_update_entry])[:20] 
           if item.value.status != 'UNCHANGED' else current_service_updates }}
    }
  loop: "{{ after_versions | dict2items }}"
  when: (has_changes or first_run) and item.value.status != 'UNCHANGED' and current_service_updates is defined and not is_status_display

- name: Update full history for each service (commit to version history)
  ansible.builtin.set_fact:
    version_history: "{{ version_history | combine({'full_history': version_history.full_history | default({}) | combine({item.key: service_record})}) }}"
  loop: "{{ after_versions | dict2items }}"
  when: (has_changes or first_run) and item.value.status != 'UNCHANGED' and service_record is defined and not is_status_display

# Record incremental changes only when not first run and changes exist
- name: Record incremental changes (unlimited entries)
  ansible.builtin.set_fact:
    version_history: >-
      {{ version_history | combine({
        'changes': ([{
          'timestamp': current_timestamp,
          'user': current_user,
          'changes': version_history_changes,
          'event_type': 'update'
        }] + version_history.changes)
      }) }}
  when: has_changes and version_history_changes is defined and version_history_changes | length > 0 and not first_run and (matrix_history_max_entries | int == 0) and not is_status_display

- name: Record incremental changes (limited entries)
  ansible.builtin.set_fact:
    version_history: >-
      {{ version_history | combine({
        'changes': ([{
          'timestamp': current_timestamp,
          'user': current_user,
          'changes': version_history_changes,
          'event_type': 'update'
        }] + version_history.changes)[: matrix_history_max_entries | int]
      }) }}
  when: has_changes and version_history_changes is defined and version_history_changes | length > 0 and not first_run and (matrix_history_max_entries | int > 0) and not is_status_display

# Update version history with last known versions
- name: Update version history with last known versions
  ansible.builtin.set_fact:
    version_history: "{{ version_history | combine({'last_versions': current_versions}) }}"
  when: not is_status_display

# Apply date-based retention cleanup (only when retention days > 0 and not in status check mode)
# FIXED: Use cross-platform date command instead of strftime filter for reliable date calculation
- name: Calculate cutoff date for retention cleanup (Linux)
  ansible.builtin.command: date -u -d "{{ matrix_history_retention_days }} days ago" +"%Y-%m-%d %H:%M:%S"
  register: linux_cutoff_date
  changed_when: false
  failed_when: false
  when:
    - matrix_history_retention_days | int > 0
    - not is_status_display
    - ansible_system == "Linux"

- name: Calculate cutoff date for retention cleanup (BSD/macOS)
  ansible.builtin.command: date -u -v-{{ matrix_history_retention_days }}d +"%Y-%m-%d %H:%M:%S"
  register: bsd_cutoff_date
  changed_when: false
  failed_when: false
  when:
    - matrix_history_retention_days | int > 0
    - not is_status_display
    - ansible_system != "Linux"

- name: Set cutoff date based on detected OS
  ansible.builtin.set_fact:
    retention_cutoff_date: >-
      {% if ansible_system == "Linux" and linux_cutoff_date.rc is defined and linux_cutoff_date.rc == 0 %}
      {{ linux_cutoff_date.stdout }}
      {% elif ansible_system != "Linux" and bsd_cutoff_date.rc is defined and bsd_cutoff_date.rc == 0 %}
      {{ bsd_cutoff_date.stdout }}
      {% else %}
      null
      {% endif %}
  when:
    - matrix_history_retention_days | int > 0
    - not is_status_display

- name: Log retention date calculation status
  ansible.builtin.debug:
    msg: >-
      {% if retention_cutoff_date is defined and retention_cutoff_date != 'null' %}
      Using retention cutoff date: {{ retention_cutoff_date }} (retention days: {{ matrix_history_retention_days }})
      {% else %}
      Warning: Could not calculate retention cutoff date. Using all history entries.
      {% endif %}
  when:
    - matrix_history_retention_days | int > 0
    - not is_status_display

# Apply retention policy with fixed date handling
- name: Apply retention policy to changes history
  ansible.builtin.set_fact:
    version_history: "{{ version_history | combine({'changes': version_history.changes | default([]) | rejectattr('timestamp', 'lt', retention_cutoff_date) | list}) }}"
  when:
    - retention_cutoff_date is defined
    - retention_cutoff_date != 'null'
    - version_history.changes is defined
    - version_history.changes | length > 0
    - not is_status_display

# Set table characters based on preference
- name: Set table characters (Unicode)
  ansible.builtin.set_fact:
    h_line: "─"
    v_line: "│"
    tl_corner: "┌"
    tr_corner: "┐"
    bl_corner: "└"
    br_corner: "┘"
    t_down: "┬"
    t_up: "┴"
    t_right: "├"
    t_left: "┤"
    cross: "┼"
    double_h_line: "═"
    double_cross: "╪"
  when:
    - after_versions | length > 0
    - matrix_table_style_unicode | bool

- name: Set table characters (ASCII)
  ansible.builtin.set_fact:
    h_line: "-"
    v_line: "|"
    tl_corner: "+"
    tr_corner: "+"
    bl_corner: "+"
    br_corner: "+"
    t_down: "+"
    t_up: "+"
    t_right: "+"
    t_left: "+"
    cross: "+"
    double_h_line: "="
    double_cross: "+"
  when:
    - after_versions | length > 0
    - not (matrix_table_style_unicode | bool)

# Build table structure with fixed column widths for proper ASCII alignment
- name: Create table header
  ansible.builtin.set_fact:
    top_line: "{{ tl_corner }}{{ h_line * 32 }}{{ t_down }}{{ h_line * 32 }}{{ t_down }}{{ h_line * 32 }}{{ t_down }}{{ h_line * 11 }}{{ tr_corner }}"
    header_row: "{{ v_line }} {{ 'SERVICE/CONTAINER' | ljust(30) }} {{ v_line }} {{ 'VERSION BEFORE' | ljust(30) }} {{ v_line }} {{ 'VERSION AFTER' | ljust(30) }} {{ v_line }} {{ 'STATUS' | ljust(9) }} {{ v_line }}"
    header_sep: "{{ t_right }}{{ double_h_line * 32 }}{{ double_cross }}{{ double_h_line * 32 }}{{ double_cross }}{{ double_h_line * 32 }}{{ double_cross }}{{ double_h_line * 11 }}{{ t_left }}"
    bottom_line: "{{ bl_corner }}{{ h_line * 32 }}{{ t_up }}{{ h_line * 32 }}{{ t_up }}{{ h_line * 32 }}{{ t_up }}{{ h_line * 11 }}{{ br_corner }}"
  when: after_versions | length > 0

# Generate table rows
- name: Generate table content
  ansible.builtin.set_fact:
    table_rows: []
  when: after_versions | length > 0

- name: Add table rows
  ansible.builtin.set_fact:
    table_rows: >-
      {{ table_rows + [
        v_line + ' ' +
        (item.key | truncate(30, true) | ljust(30)) + ' ' +
        v_line + ' ' +
        ((item.value.previous | default('-') | string | truncate(30, true)) | ljust(30)) + ' ' +
        v_line + ' ' +
        ((item.value.current | string | truncate(30, true)) | ljust(30)) + ' ' +
        v_line + ' ' +
        (item.value.status | ljust(9)) + ' ' +
        v_line
      ] }}
  loop: "{{ after_versions | dict2items | sort(attribute='key') }}"
  when: after_versions | length > 0

# Create complete table output
- name: Build complete table
  ansible.builtin.set_fact:
    version_summary_table: |
      MATRIX VERSION CHANGES - {{ ansible_date_time.iso8601 }}

      {{ top_line }}
      {{ header_row }}
      {{ header_sep }}
      {{ table_rows | join('\n') }}
      {{ bottom_line }}

      Total matrix containers: {{ after_versions | length }}

      {% if is_status_display %}
      [CURRENT STATUS DISPLAY - NO CHANGES RECORDED]
      {% elif has_changes %}
      [NEW VERSION CHANGES RECORDED]
      {% elif first_run %}
      [INITIAL STATE RECORDED]
      {% else %}
      [NO CHANGES DETECTED]
      {% endif %}
  when: after_versions | length > 0

# Display table using debug module
- name: Display formatted table
  ansible.builtin.debug:
    msg: "{{ version_summary_table.split('\n') }}"
  when:
    - current_versions | length > 0
    - after_versions | length > 0

# Display empty message if no containers found
- name: Display empty table message
  ansible.builtin.debug:
    msg: "{{ ['MATRIX VERSION CHANGES - ' + ansible_date_time.iso8601, '', 'No Matrix containers found running. ' + ('In status check mode - showing current state only.' if is_status_display else 'Start services first to see version information.')] }}"
  when: current_versions | length == 0 or after_versions | length == 0

# Write facts to filesystem
- name: Write current versions to fact file
  ansible.builtin.copy:
    content: "{{ current_versions | to_nice_json }}"
    dest: "/etc/ansible/facts.d/{{ matrix_versions_fact_file }}"
    mode: '0644'
  become: true
  when: not is_status_display

- name: Write version history to fact file
  ansible.builtin.copy:
    content: "{{ version_history | to_nice_json }}"
    dest: "/etc/ansible/facts.d/{{ matrix_history_fact_file }}"
    mode: '0644'
  become: true
  when: not is_status_display

